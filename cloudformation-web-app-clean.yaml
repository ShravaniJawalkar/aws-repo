AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for EC2 instance with SQS/SNS web application deployment'

Parameters:
  ProjectName:
    Type: String
    Default: webproject
    Description: Project name used for resource naming
  
  ProjectInstanceType:
    Type: String
    Description: EC2 instance type
    Default: t3.micro
    AllowedValues:
      - t2.micro
      - t2.small
      - t3.micro
      - t3.small
  
  SSHLocation:
    Type: String
    Description: IP address range that can SSH to EC2 instances
    Default: 0.0.0.0/0
  
  KeyName:
    Type: String
    Description: EC2 Key Pair name for SSH access
    Default: web-server
  
  SQSQueueURL:
    Type: String
    Description: SQS Queue URL for notifications
  
  SNSTopicARN:
    Type: String
    Description: SNS Topic ARN for notifications

Resources:
  WebAppInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-instance-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - arn:aws:s3:::*
                  - arn:aws:s3:::*/*
        
        - PolicyName: SQSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:GetQueueUrl
                Resource: arn:aws:sqs:ap-south-1:*:*
        
        - PolicyName: SNSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish
                  - sns:Subscribe
                  - sns:Unsubscribe
                  - sns:ListSubscriptionsByTopic
                Resource: arn:aws:sns:ap-south-1:*:*
        
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                Resource: arn:aws:logs:ap-south-1:*:*

  WebAppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref WebAppInstanceRole

  WebAppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${ProjectName}-web-sg'
      GroupDescription: Security group for web application
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref SSHLocation
          Description: SSH access
        
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: HTTP access
        
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS access
        
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 0.0.0.0/0
          Description: Application port
      
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-web-sg'

  WebAppInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0a289b56122fa70e8
      InstanceType: !Ref ProjectInstanceType
      KeyName: !Ref KeyName
      IamInstanceProfile: !Ref WebAppInstanceProfile
      SecurityGroupIds:
        - !Ref WebAppSecurityGroup
      
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-instance'
        - Key: Environment
          Value: production
      
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -e
          
          yum update -y
          yum install -y git curl wget
          
          curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
          yum install -y nodejs
          
          mkdir -p /var/www/web-dynamic-app
          cd /var/www/web-dynamic-app
          
          cat > package.json << 'EOF'
          {
            "name": "web-dynamic-app",
            "version": "1.0.0",
            "description": "Web application with SQS/SNS subscription feature",
            "main": "app.js",
            "dependencies": {
              "express": "^4.18.0",
              "aws-sdk": "^2.1400.0",
              "uuid": "^9.0.0",
              "axios": "^1.4.0",
              "dotenv": "^16.0.0"
            },
            "scripts": {
              "start": "node app.js",
              "dev": "nodemon app.js"
            },
            "keywords": ["aws", "sqs", "sns", "notification"],
            "author": "",
            "license": "ISC"
          }
          EOF
          
          cat > .env << 'EOF'
          AWS_REGION=ap-south-1
          AWS_PROFILE=default
          PORT=8080
          NODE_ENV=production
          SQS_QUEUE_URL=${SQSQueueURL}
          SNS_TOPIC_ARN=${SNSTopicARN}
          WORKER_INTERVAL_MS=30000
          SQS_BATCH_SIZE=10
          SQS_VISIBILITY_TIMEOUT=300
          LOG_LEVEL=info
          LOG_FORMAT=json
          ENABLE_EMAIL_NOTIFICATIONS=true
          ENABLE_MESSAGE_FILTERING=true
          ENABLE_DEBUG_LOGGING=false
          EOF
          
          cat > app.js << 'APPEOF'
          const express = require('express');
          const aws = require('aws-sdk');
          const { v4: uuidv4 } = require('uuid');
          const dotenv = require('dotenv');
          
          dotenv.config();
          
          const app = express();
          const PORT = process.env.PORT || 8080;
          
          const sqs = new aws.SQS({ region: 'ap-south-1' });
          const sns = new aws.SNS({ region: 'ap-south-1' });
          
          const QUEUE_URL = process.env.SQS_QUEUE_URL || '';
          const TOPIC_ARN = process.env.SNS_TOPIC_ARN || '';
          
          app.use(express.json());
          app.use(express.urlencoded({ extended: true }));
          
          app.post('/api/subscribe', async (req, res) => {
            try {
              const email = req.query.email || req.body.email;
              
              if (!email || !isValidEmail(email)) {
                return res.status(400).json({ error: 'Valid email is required' });
              }
              
              const result = await sns.subscribe({
                TopicArn: TOPIC_ARN,
                Protocol: 'email',
                Endpoint: email
              }).promise();
              
              res.status(200).json({
                success: true,
                message: `Subscription pending confirmation. Check ${email} for confirmation.`,
                subscriptionArn: result.SubscriptionArn
              });
            } catch (error) {
              console.error('Subscription error:', error);
              res.status(500).json({ error: 'Failed to subscribe email', details: error.message });
            }
          });
          
          app.post('/api/unsubscribe', async (req, res) => {
            try {
              const email = req.query.email || req.body.email;
              
              if (!email || !isValidEmail(email)) {
                return res.status(400).json({ error: 'Valid email is required' });
              }
              
              const subscriptions = await sns.listSubscriptionsByTopic({ TopicArn: TOPIC_ARN }).promise();
              const subscription = subscriptions.Subscriptions.find(
                sub => sub.Protocol === 'email' && sub.Endpoint === email
              );
              
              if (!subscription) {
                return res.status(404).json({ error: 'Email not found in subscriptions' });
              }
              
              await sns.unsubscribe({ SubscriptionArn: subscription.SubscriptionArn }).promise();
              
              res.status(200).json({
                success: true,
                message: `${email} has been unsubscribed`
              });
            } catch (error) {
              console.error('Unsubscription error:', error);
              res.status(500).json({ error: 'Failed to unsubscribe email', details: error.message });
            }
          });
          
          app.get('/api/subscriptions', async (req, res) => {
            try {
              const subscriptions = await sns.listSubscriptionsByTopic({ TopicArn: TOPIC_ARN }).promise();
              
              res.status(200).json({
                success: true,
                count: subscriptions.Subscriptions.length,
                subscriptions: subscriptions.Subscriptions.map(sub => ({
                  email: sub.Endpoint,
                  protocol: sub.Protocol,
                  status: sub.SubscriptionArn === 'PendingConfirmation' ? 'pending' : 'active'
                }))
              });
            } catch (error) {
              console.error('Error listing subscriptions:', error);
              res.status(500).json({ error: 'Failed to list subscriptions', details: error.message });
            }
          });
          
          app.post('/api/upload', async (req, res) => {
            try {
              const fileName = req.body.fileName || req.query.fileName || 'sample-image.jpg';
              const fileSize = req.body.fileSize || req.query.fileSize || '1024000';
              const description = req.body.description || req.query.description || 'No description';
              
              const fileExtension = getFileExtension(fileName);
              
              const uploadEvent = {
                eventId: uuidv4(),
                fileName: fileName,
                fileSize: parseInt(fileSize),
                fileExtension: fileExtension,
                description: description,
                timestamp: new Date().toISOString(),
                uploadedBy: 'web-application'
              };
              
              const sqsResult = await sqs.sendMessage({
                QueueUrl: QUEUE_URL,
                MessageBody: JSON.stringify(uploadEvent),
                MessageAttributes: {
                  ImageExtension: {
                    StringValue: fileExtension,
                    DataType: 'String'
                  },
                  EventType: {
                    StringValue: 'ImageUpload',
                    DataType: 'String'
                  }
                }
              }).promise();
              
              res.status(201).json({
                success: true,
                message: 'Image uploaded. Notification queued.',
                uploadEvent: uploadEvent,
                messageId: sqsResult.MessageId
              });
            } catch (error) {
              console.error('Upload error:', error);
              res.status(500).json({ error: 'Failed to upload image', details: error.message });
            }
          });
          
          async function processSQSMessages() {
            try {
              const messages = await sqs.receiveMessage({
                QueueUrl: QUEUE_URL,
                MaxNumberOfMessages: 10,
                WaitTimeSeconds: 5,
                MessageAttributeNames: ['All']
              }).promise();
              
              if (!messages.Messages) return;
              
              for (const message of messages.Messages) {
                try {
                  const uploadEvent = JSON.parse(message.Body);
                  
                  await sns.publish({
                    TopicArn: TOPIC_ARN,
                    Subject: `Image Upload: ${uploadEvent.fileName}`,
                    Message: formatNotification(uploadEvent),
                    MessageAttributes: {
                      ImageExtension: {
                        StringValue: uploadEvent.fileExtension,
                        DataType: 'String'
                      }
                    }
                  }).promise();
                  
                  await sqs.deleteMessage({
                    QueueUrl: QUEUE_URL,
                    ReceiptHandle: message.ReceiptHandle
                  }).promise();
                } catch (err) {
                  console.error('Error processing message:', err);
                }
              }
            } catch (error) {
              console.error('Error in processSQSMessages:', error);
            }
          }
          
          function formatNotification(event) {
            return `Image Upload Notification\n========================\nFile: ${event.fileName}\nSize: ${(event.fileSize / 1024 / 1024).toFixed(2)} MB\nTime: ${event.timestamp}\nDescription: ${event.description}`;
          }
          
          function isValidEmail(email) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
          }
          
          function getFileExtension(fileName) {
            const lastDot = fileName.lastIndexOf('.');
            return lastDot === -1 ? '' : fileName.substring(lastDot).toLowerCase();
          }
          
          app.post('/admin/process-queue', async (req, res) => {
            try {
              await processSQSMessages();
              res.status(200).json({ success: true, message: 'Queue processing triggered' });
            } catch (error) {
              res.status(500).json({ error: 'Failed to process queue', details: error.message });
            }
          });
          
          app.get('/admin/queue-status', async (req, res) => {
            try {
              const attributes = await sqs.getQueueAttributes({
                QueueUrl: QUEUE_URL,
                AttributeNames: ['All']
              }).promise();
              
              res.status(200).json({
                success: true,
                messages: {
                  available: parseInt(attributes.Attributes.ApproximateNumberOfMessages),
                  delayed: parseInt(attributes.Attributes.ApproximateNumberOfMessagesDelayed)
                }
              });
            } catch (error) {
              res.status(500).json({ error: 'Failed to get queue status' });
            }
          });
          
          app.get('/health', (req, res) => {
            res.status(200).json({ status: 'healthy', timestamp: new Date().toISOString() });
          });
          
          app.get('/', (req, res) => {
            res.send(`<html><head><title>Web App</title></head><body style="font-family:Arial;padding:20px"><h1>SQS/SNS Web Application</h1><ul><li>POST /api/subscribe?email=user@example.com</li><li>POST /api/unsubscribe?email=user@example.com</li><li>GET /api/subscriptions</li><li>POST /api/upload?fileName=image.jpg&fileSize=1024000</li><li>GET /health</li><li>GET /admin/queue-status</li><li>POST /admin/process-queue</li></ul></body></html>`);
          });
          
          let workerInterval;
          const server = app.listen(PORT, () => {
            console.log(`App listening on port ${PORT}`);
            console.log(`SQS: ${QUEUE_URL}`);
            console.log(`SNS: ${TOPIC_ARN}`);
            processSQSMessages();
            workerInterval = setInterval(processSQSMessages, 30000);
          });
          
          process.on('SIGTERM', () => {
            if (workerInterval) clearInterval(workerInterval);
            server.close(() => process.exit(0));
          });
          APPEOF
          
          npm install
          
          cat > /etc/systemd/system/web-app.service << 'EOF'
          [Unit]
          Description=Web Application with SQS/SNS
          After=network.target
          
          [Service]
          Type=simple
          User=ec2-user
          WorkingDirectory=/var/www/web-dynamic-app
          ExecStart=/usr/bin/node /var/www/web-dynamic-app/app.js
          Restart=always
          RestartSec=10
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          systemctl daemon-reload
          systemctl enable web-app
          systemctl start web-app

Outputs:
  InstanceId:
    Description: Instance ID of the EC2 instance
    Value: !Ref WebAppInstance
  
  InstancePublicIP:
    Description: Public IP address of the EC2 instance
    Value: !GetAtt WebAppInstance.PublicIp
  
  InstancePrivateIP:
    Description: Private IP address of the EC2 instance
    Value: !GetAtt WebAppInstance.PrivateIp
  
  SecurityGroupId:
    Description: Security Group ID
    Value: !Ref WebAppSecurityGroup
  
  ApplicationURL:
    Description: URL to access the web application
    Value: !Sub 'http://${WebAppInstance.PublicIp}:8080'
  
  SSHCommand:
    Description: Command to SSH into the instance
    Value: !Sub 'ssh -i web-server.pem ec2-user@${WebAppInstance.PublicIp}'
